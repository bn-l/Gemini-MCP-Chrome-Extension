/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/content.ts":
/*!************************!*\
  !*** ./src/content.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Geminiページの要素のセレクタ\nconst SELECTORS = {\n    // 入力欄のセレクタ（実際のGeminiページに合わせて調整が必要）\n    INPUT_AREA: 'textarea[aria-label=\"プロンプトを入力\"]',\n    // 送信ボタンのセレクタ（実際のGeminiページに合わせて調整が必要）\n    SEND_BUTTON: 'button[aria-label=\"送信\"]',\n    // 応答コンテナのセレクタ（実際のGeminiページに合わせて調整が必要）\n    RESPONSE_CONTAINER: '.response-container'\n};\n// 初期化時にコンソールにメッセージを表示\nconsole.log('Gemini MCP Connector: コンテンツスクリプトが読み込まれました');\n// 入力欄にテキストを設定する関数\nfunction setInput(text) {\n    return new Promise((resolve) => {\n        try {\n            const inputElement = document.querySelector(SELECTORS.INPUT_AREA);\n            if (!inputElement) {\n                console.error('入力欄が見つかりません');\n                resolve(false);\n                return;\n            }\n            // 入力欄にフォーカスを当てる\n            inputElement.focus();\n            // 入力欄の値を設定\n            inputElement.value = text;\n            // 入力イベントを発火させて、Geminiの内部状態を更新\n            const inputEvent = new Event('input', { bubbles: true });\n            inputElement.dispatchEvent(inputEvent);\n            console.log('テキストを入力しました:', text);\n            resolve(true);\n        }\n        catch (error) {\n            console.error('テキスト入力中にエラーが発生しました:', error);\n            resolve(false);\n        }\n    });\n}\n// 送信ボタンをクリックする関数\nfunction clickSend() {\n    return new Promise((resolve) => {\n        try {\n            const sendButton = document.querySelector(SELECTORS.SEND_BUTTON);\n            if (!sendButton) {\n                console.error('送信ボタンが見つかりません');\n                resolve(false);\n                return;\n            }\n            // ボタンが無効化されていないか確認\n            if (sendButton.disabled) {\n                console.error('送信ボタンが無効化されています');\n                resolve(false);\n                return;\n            }\n            // ボタンをクリック\n            sendButton.click();\n            console.log('送信ボタンをクリックしました');\n            // 応答監視を開始\n            startResponseObserver();\n            resolve(true);\n        }\n        catch (error) {\n            console.error('送信ボタンクリック中にエラーが発生しました:', error);\n            resolve(false);\n        }\n    });\n}\n// 応答を監視するMutationObserver\nlet responseObserver = null;\nlet isObserving = false;\n// 応答監視を開始する関数\nfunction startResponseObserver() {\n    if (isObserving) {\n        return;\n    }\n    try {\n        console.log('応答監視を開始します');\n        // 応答コンテナを取得\n        const responseContainer = document.querySelector(SELECTORS.RESPONSE_CONTAINER);\n        if (!responseContainer) {\n            console.error('応答コンテナが見つかりません');\n            return;\n        }\n        // 既存のObserverをクリーンアップ\n        if (responseObserver) {\n            responseObserver.disconnect();\n        }\n        isObserving = true;\n        // 新しいObserverを作成\n        responseObserver = new MutationObserver((mutations) => {\n            // 応答が完了したかどうかを判断する処理\n            // 例: 「生成中...」のインジケータが消えたかどうかを確認\n            // 応答テキストを抽出\n            const responseText = extractResponseText();\n            if (responseText) {\n                console.log('応答テキストを抽出しました:', responseText);\n                // 応答が完了したと判断したら、Observerを停止\n                responseObserver === null || responseObserver === void 0 ? void 0 : responseObserver.disconnect();\n                isObserving = false;\n                // 応答テキストをbackground.jsに送信\n                sendResponseToBackground(responseText);\n            }\n        });\n        // 監視設定\n        responseObserver.observe(responseContainer, {\n            childList: true,\n            subtree: true,\n            characterData: true\n        });\n    }\n    catch (error) {\n        console.error('応答監視の開始中にエラーが発生しました:', error);\n        isObserving = false;\n    }\n}\n// 応答テキストを抽出する関数\nfunction extractResponseText() {\n    try {\n        const responseContainer = document.querySelector(SELECTORS.RESPONSE_CONTAINER);\n        if (!responseContainer) {\n            return null;\n        }\n        // 応答テキストを抽出（実際のGeminiページの構造に合わせて調整が必要）\n        // 例: すべてのテキストノードを連結する\n        const textContent = responseContainer.textContent || '';\n        return textContent.trim();\n    }\n    catch (error) {\n        console.error('応答テキストの抽出中にエラーが発生しました:', error);\n        return null;\n    }\n}\n// 応答テキストをbackground.jsに送信する関数\nfunction sendResponseToBackground(text) {\n    const response = {\n        status: 'success',\n        event: 'responseReceived',\n        payload: {\n            text: text\n        }\n    };\n    chrome.runtime.sendMessage(response);\n}\n// background.jsからのメッセージを受信\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log('background.jsからメッセージを受信:', message);\n    // メッセージの種類に応じて処理を分岐\n    switch (message.command) {\n        case 'setInput':\n            setInput(message.payload.text)\n                .then((success) => {\n                if (!success) {\n                    sendErrorToBackground('テキスト入力に失敗しました');\n                }\n            });\n            break;\n        case 'clickSend':\n            clickSend()\n                .then((success) => {\n                if (!success) {\n                    sendErrorToBackground('送信ボタンクリックに失敗しました');\n                }\n            });\n            break;\n        default:\n            console.error('不明なコマンドです:', message);\n            sendErrorToBackground(`不明なコマンド: ${JSON.stringify(message)}`);\n            break;\n    }\n    // 非同期レスポンスを許可\n    return true;\n});\n// エラーメッセージをbackground.jsに送信する関数\nfunction sendErrorToBackground(errorMessage) {\n    const errorResponse = {\n        status: 'error',\n        message: errorMessage\n    };\n    chrome.runtime.sendMessage(errorResponse);\n}\n// ページ読み込み完了時の処理\nwindow.addEventListener('load', () => {\n    console.log('Gemini MCP Connector: ページが完全に読み込まれました');\n});\n\n\n//# sourceURL=webpack://GeminiMcpGateway/./src/content.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/content.ts"](0, __webpack_exports__);
/******/ 	
/******/ })()
;