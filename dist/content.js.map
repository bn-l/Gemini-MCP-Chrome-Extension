{"version":3,"file":"content.js","mappings":"mBAIAA,OAAOC,iBAAiB,QAAQ,KAI5B,GAFwBC,SAASC,cAAc,uCAE5B,CACfC,QAAQC,IAAI,uDAAwD,uDACpE,MAAMC,EAAY,CACdC,WAAY,sCACZC,YAAa,gCACbC,mBAAoB,6CAGxB,IAAIC,EAAmB,GAoDnBC,EAAmB,KACnBC,GAAc,EACdC,EAAkB,KACtB,SAASC,IACL,GAAIF,EACA,OACJ,MAAMG,EAAiBb,SAASc,KAC5BL,GACAA,EAAiBM,aACrBL,GAAc,EACdD,EAAmB,IAAIO,kBAAiB,KAChCL,GACAM,aAAaN,GACjBA,EAAkBb,OAAOoB,YAAW,KAChC,MAAMC,EAAYC,IAEdD,GAAaA,IAAcX,IAC3BN,QAAQC,IAAI,oBAAqBgB,GACjCX,EAAmBW,EACnBE,EAAyBF,GACzBV,SAAoEA,EAAiBM,aACrFL,GAAc,KAEnB,QAEPD,EAAiBa,QAAQT,EAAgB,CAAEU,WAAW,EAAMC,SAAS,EAAMC,eAAe,EAAMC,YAAY,GAChH,CACA,SAASN,IACL,IACI,MAAMO,EAAe3B,SAAS4B,iBAAiBxB,EAAUG,oBACzD,OAA4B,IAAxBoB,EAAaE,OACN,MACYF,EAAaA,EAAaE,OAAS,GACnCC,aAAe,IAAIC,MAC9C,CACA,MAAOC,GAEH,OADA9B,QAAQ8B,MAAM,yBAA0BA,GACjC,IACX,CACJ,CACA,SAASX,EAAyBY,GAC9B,MAAMC,EAAW,CAAEC,OAAQ,UAAWC,MAAO,mBAAoBC,QAAS,CAAEJ,KAAMA,IAClFK,OAAOC,QAAQC,YAAYN,EAC/B,CACA,SAASO,EAAsBC,GAC3B,MAAMC,EAAgB,CAAER,OAAQ,QAASS,QAASF,GAClDJ,OAAOC,QAAQC,YAAYG,EAC/B,CACAL,OAAOC,QAAQM,UAAUC,aAAY,CAACF,EAASG,EAAQC,KACnD,OAAQJ,EAAQK,SACZ,IAAK,YArGKhB,EAsGGW,EAAQP,QAAQJ,KArG1B,IAAIiB,SAASC,IAChB,IACI,MAAMC,EAAepD,SAASC,cAAcG,EAAUC,YACtD,IAAK+C,EAGD,OAFAlD,QAAQ8B,MAAM,oBACdmB,GAAQ,GAGZC,EAAaC,QACbD,EAAatB,YAAcG,EAC3B,MAAMqB,EAAa,IAAIC,MAAM,QAAS,CAAEC,SAAS,IACjDJ,EAAaK,cAAcH,GAC3BH,GAAQ,EACZ,CACA,MAAOnB,GACH9B,QAAQ8B,MAAM,sBAAuBA,GACrCmB,GAAQ,EACZ,MAoFmCO,MAAKC,IAAkBA,GAClDlB,EAAsB,oBAC1B,MACJ,IAAK,YAnFF,IAAIS,SAASC,IAEhB,IAAIS,EAAU,EACd,MAAMC,EAAaC,aAAY,KAC3B,MAAMC,EAAa/D,SAASC,cAAcG,EAAUE,aACpD,IAAIyD,GAAeA,EAAWC,SAe9BJ,IACIA,GApBW,KAqBXK,cAAcJ,GACd3D,QAAQ8B,MAAM,6BACdmB,GAAQ,QAnBZ,CACIc,cAAcJ,GACd,IACIE,EAAWG,QAEX1D,EAAmB,GACnBI,IACAuC,GAAQ,EACZ,CACA,MAAOnB,GACH9B,QAAQ8B,MAAM,yBAA0BA,GACxCmB,GAAQ,EACZ,CAEJ,IAOD,QA0DaO,MAAKC,IAAkBA,GAC/BlB,EAAsB,uBA3GtC,IAAkBR,EA8Gd,OAAO,KAGXK,OAAOC,QAAQC,YAAY,CAAE2B,KAAM,iBACvC,I","sources":["webpack://GeminiMcpGateway/./src/content.ts"],"sourcesContent":["\"use strict\";\n// src/content.ts (真・最終完成版)\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ★★★ 修正箇所：ページの読み込みが完全に完了するまで、すべての処理の開始を待つ ★★★\nwindow.addEventListener('load', () => {\n    // このフレームが操作対象のフレームか確認する\n    const isTargetFrame = !!document.querySelector('div[aria-label=\"ここにプロンプトを入力してください\"]');\n    // 「当たり」のフレームでなければ、このスクリプトはここで処理を終了する\n    if (isTargetFrame) {\n        console.log('%c ★ Gemini Content Script Loaded in TARGET FRAME! ★', 'color: #42f560; font-size: 16px; font-weight: bold;');\n        const SELECTORS = {\n            INPUT_AREA: 'div[aria-label=\"ここにプロンプトを入力してください\"]',\n            SEND_BUTTON: 'button[aria-label=\"プロンプトを送信\"]',\n            RESPONSE_CONTAINER: 'div[id^=\"model-response-message-content\"]'\n        };\n        // 最後に送信した応答を記憶する変数\n        let lastSentResponse = '';\n        function setInput(text) {\n            return new Promise((resolve) => {\n                try {\n                    const inputElement = document.querySelector(SELECTORS.INPUT_AREA);\n                    if (!inputElement) {\n                        console.error('入力欄が見つかりません');\n                        resolve(false);\n                        return;\n                    }\n                    inputElement.focus();\n                    inputElement.textContent = text;\n                    const inputEvent = new Event('input', { bubbles: true });\n                    inputElement.dispatchEvent(inputEvent);\n                    resolve(true);\n                }\n                catch (error) {\n                    console.error('テキスト入力中にエラーが発生しました:', error);\n                    resolve(false);\n                }\n            });\n        }\n        function clickSend() {\n            return new Promise((resolve) => {\n                const maxRetries = 30;\n                let retries = 0;\n                const intervalId = setInterval(() => {\n                    const sendButton = document.querySelector(SELECTORS.SEND_BUTTON);\n                    if (sendButton && !sendButton.disabled) {\n                        clearInterval(intervalId);\n                        try {\n                            sendButton.click();\n                            // 新しい応答に備えて、記憶した応答をリセットする\n                            lastSentResponse = '';\n                            startResponseObserver();\n                            resolve(true);\n                        }\n                        catch (error) {\n                            console.error('送信ボタンクリック中にエラーが発生しました:', error);\n                            resolve(false);\n                        }\n                        return;\n                    }\n                    retries++;\n                    if (retries >= maxRetries) {\n                        clearInterval(intervalId);\n                        console.error('送信ボタンが見つからないか、有効になりませんでした');\n                        resolve(false);\n                    }\n                }, 100);\n            });\n        }\n        let responseObserver = null;\n        let isObserving = false;\n        let debounceTimeout = null;\n        function startResponseObserver() {\n            if (isObserving)\n                return;\n            const observerTarget = document.body;\n            if (responseObserver)\n                responseObserver.disconnect();\n            isObserving = true;\n            responseObserver = new MutationObserver(() => {\n                if (debounceTimeout)\n                    clearTimeout(debounceTimeout);\n                debounceTimeout = window.setTimeout(() => {\n                    const finalText = extractResponseText();\n                    // 取得したテキストが新しく、かつ空でない場合のみ送信\n                    if (finalText && finalText !== lastSentResponse) {\n                        console.log('新しい応答を確定し、抽出しました:', finalText);\n                        lastSentResponse = finalText;\n                        sendResponseToBackground(finalText);\n                        responseObserver === null || responseObserver === void 0 ? void 0 : responseObserver.disconnect();\n                        isObserving = false;\n                    }\n                }, 500);\n            });\n            responseObserver.observe(observerTarget, { childList: true, subtree: true, characterData: true, attributes: true });\n        }\n        function extractResponseText() {\n            try {\n                const allResponses = document.querySelectorAll(SELECTORS.RESPONSE_CONTAINER);\n                if (allResponses.length === 0)\n                    return null;\n                const latestResponse = allResponses[allResponses.length - 1];\n                return (latestResponse.textContent || '').trim();\n            }\n            catch (error) {\n                console.error('応答テキストの抽出中にエラーが発生しました:', error);\n                return null;\n            }\n        }\n        function sendResponseToBackground(text) {\n            const response = { status: 'success', event: 'responseReceived', payload: { text: text } };\n            chrome.runtime.sendMessage(response);\n        }\n        function sendErrorToBackground(errorMessage) {\n            const errorResponse = { status: 'error', message: errorMessage };\n            chrome.runtime.sendMessage(errorResponse);\n        }\n        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n            switch (message.command) {\n                case 'setInput':\n                    setInput(message.payload.text).then(success => { if (!success)\n                        sendErrorToBackground('テキスト入力に失敗しました'); });\n                    break;\n                case 'clickSend':\n                    clickSend().then(success => { if (!success)\n                        sendErrorToBackground('送信ボタンクリックに失敗しました'); });\n                    break;\n            }\n            return true;\n        });\n        // 司令塔(background.ts)に「準備完了」を通知する\n        chrome.runtime.sendMessage({ type: 'content_ready' });\n    }\n});\n"],"names":["window","addEventListener","document","querySelector","console","log","SELECTORS","INPUT_AREA","SEND_BUTTON","RESPONSE_CONTAINER","lastSentResponse","responseObserver","isObserving","debounceTimeout","startResponseObserver","observerTarget","body","disconnect","MutationObserver","clearTimeout","setTimeout","finalText","extractResponseText","sendResponseToBackground","observe","childList","subtree","characterData","attributes","allResponses","querySelectorAll","length","textContent","trim","error","text","response","status","event","payload","chrome","runtime","sendMessage","sendErrorToBackground","errorMessage","errorResponse","message","onMessage","addListener","sender","sendResponse","command","Promise","resolve","inputElement","focus","inputEvent","Event","bubbles","dispatchEvent","then","success","retries","intervalId","setInterval","sendButton","disabled","clearInterval","click","type"],"sourceRoot":""}