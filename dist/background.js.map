{"version":3,"file":"background.js","mappings":"uCAQA,IAAIA,EAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC1F,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,GAAS,CAAE,MAAOG,GAAKL,EAAOK,EAAI,CAAE,CAC7F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,EAAQ,KAIjBO,KAAKR,EAAWK,EAAW,CAC7GH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,OAClE,GACJ,EACAO,OAAOC,eAAeC,EAAS,aAAc,CAAEX,OAAO,IAItD,IAAIY,EAAa,KAEbC,EAAkB,CAAC,EAEnBC,EAAe,CAAC,EAmGpB,SAASC,EAAwBC,GAC7B,OAAO1B,EAAUC,UAAM,OAAQ,GAAQ,YAEnC,MAAM0B,QAAaC,OAAOD,KAAKE,MAAM,CAAEC,IAAK,gCAC5C,GAAoB,IAAhBH,EAAKI,OACL,OACJ,MAAMC,EAAYL,EAAK,GACvB,GAAIK,QAAqC,IAAjBA,EAAUC,GAAoB,CAClD,MAAMC,EAAQF,EAAUC,GAExB,IAAKV,EAAgBW,GAKjB,OAJAC,QAAQC,KAAK,wBAAwBF,uCAA4CR,GAC5EF,EAAaU,KACdV,EAAaU,GAAS,SAC1BV,EAAaU,GAAOG,KAAKX,GAI7BE,OAAOD,KAAKW,YAAYJ,EAAOR,EACnC,CACJ,GACJ,EA/GA,SAASa,IACL,IACIJ,QAAQK,IAAI,4DACZlB,EAAaM,OAAOa,QAAQC,cAlBlB,kCAoBVpB,EAAWqB,UAAUC,aAAalB,IAC9BD,EAAwBC,MAG5BJ,EAAWuB,aAAaD,aAAY,KAChCT,QAAQK,IAAI,oDAAqD,eACjE,MAAMM,EAAQlB,OAAOa,QAAQM,UACzBD,GAASA,EAAMpB,SACfS,QAAQW,MAAM,qCAAsCA,EAAMpB,SAC9DJ,EAAa,KAIb0B,WAAWT,EAAqB,QAEpCJ,QAAQK,IAAI,4DAA6D,kBAEzEZ,OAAOD,KAAKE,MAAM,CAAEC,IAAK,gCAAkCH,IACvDA,EAAKsB,SAAQC,IACLA,EAAIjB,KACJE,QAAQK,IAAI,uDAAuDU,EAAIjB,MACvEL,OAAOD,KAAKW,YAAYY,EAAIjB,GAAI,CAAEkB,QAAS,sBAI3D,CACA,MAAOL,GAECA,GAASA,EAAMpB,QACfS,QAAQW,MAAM,sCAAuCA,EAAMpB,SAE3DS,QAAQW,MAAM,6DAClBE,WAAWT,EAAqB,IACpC,CACJ,CAEAA,GASAX,OAAOa,QAAQE,UAAUC,aAAY,CAAClB,EAAS0B,KAC3C,IAAIC,EAEJ,GAAID,EAAOF,MAAkC,QAAzBG,EAAKD,EAAOF,IAAIpB,WAAwB,IAAPuB,OAAgB,EAASA,EAAGC,SAAS,sBAAuB,CAC7G,MAAMpB,EAAQkB,EAAOF,IAAIjB,GACzB,GAAIC,GAEqB,kBAAjBR,EAAQ6B,KAWR,OAVApB,QAAQK,IAAI,8BAA8BN,kBAAuB,iBACjEX,EAAgBW,IAAS,OAErBV,EAAaU,IAAUV,EAAaU,GAAOH,OAAS,IACpDI,QAAQK,IAAI,4BAA4BhB,EAAaU,GAAOH,qCAAqCG,KACjGV,EAAaU,GAAOe,SAAQO,IACxB5B,OAAOD,KAAKW,YAAYJ,EAAOsB,aAE5BhC,EAAaU,KAM5BR,EAAQ+B,QAAUnC,GAClBA,EAAWoC,YAAYhC,EAE/B,MAEU0B,EAAOF,KAAOxB,EAAQyB,SAC5B1B,EAAwBC,GAE5B,OAAO,I,IC9GS,KAAK,EADC,CAAC,E","sources":["webpack://GeminiMcpGateway/./src/background.ts","webpack://GeminiMcpGateway/webpack/startup"],"sourcesContent":["\"use strict\";\n/**\n * background.ts\n *\n * このファイルはChrome拡張機能のバックグラウンドスクリプトとして機能し、\n * Native Messagingを使用して外部のMCPサーバーと通信します。\n * また、Gemini Webページを開いているタブとの通信も管理します。\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Native Messagingホスト名（MCPサーバー側の設定と一致させる必要があります）\nconst HOST_NAME = 'com.example.gemini_mcp_gateway';\n// Native Messagingポート（MCPサーバーとの通信に使用）\nlet nativePort = null;\n// Geminiタブの準備状態を追跡するオブジェクト（タブID => 準備完了フラグ）\nlet geminiTabStatus = {};\n// 準備ができていないタブへのメッセージキュー（タブID => メッセージ配列）\nlet messageQueue = {};\n/**\n * Native Messagingホストに接続する関数\n *\n * この関数は外部のMCPサーバー（Native Messagingホスト）への接続を確立し、\n * メッセージの送受信とエラー処理を設定します。\n * 接続が切断された場合は、5秒後に再接続を試みます。\n * 接続成功時には、既存のGeminiタブに準備確認メッセージを送信します。\n */\nfunction connectToNativeHost() {\n    try {\n        console.log('[MCP-Background] Attempting to connect to native host...');\n        nativePort = chrome.runtime.connectNative(HOST_NAME);\n        // MCPサーバーからのメッセージを受信したときの処理\n        nativePort.onMessage.addListener((message) => {\n            sendCommandsToGeminiTab(message);\n        });\n        // 接続が切断されたときの処理\n        nativePort.onDisconnect.addListener(() => {\n            console.log('%c[MCP-Background] Disconnected from native host.', 'color: red;');\n            const error = chrome.runtime.lastError;\n            if (error && error.message)\n                console.error('[MCP-Background] Disconnect error:', error.message);\n            nativePort = null;\n            // ★★★ 状態のリセットは行わない ★★★\n            // geminiTabStatus = {};\n            // messageQueue = {};\n            setTimeout(connectToNativeHost, 5000); // 5秒後に再接続を試みる\n        });\n        console.log('%c[MCP-Background] Successfully connected to native host.', 'color: orange;');\n        // 接続成功時に、既存のGeminiタブに準備OKか確認する（点呼）\n        chrome.tabs.query({ url: \"https://gemini.google.com/*\" }, (tabs) => {\n            tabs.forEach(tab => {\n                if (tab.id) {\n                    console.log(`[MCP-Background] Sending readiness check to Tab ID: ${tab.id}`);\n                    chrome.tabs.sendMessage(tab.id, { command: 'areYouReady' });\n                }\n            });\n        });\n    }\n    catch (error) {\n        // 接続エラー時の処理\n        if (error && error.message)\n            console.error('[MCP-Background] Failed to connect:', error.message);\n        else\n            console.error('[MCP-Background] Failed to connect with an unknown error.');\n        setTimeout(connectToNativeHost, 5000); // 5秒後に再接続を試みる\n    }\n}\n// Native Messagingホストへの接続を開始\nconnectToNativeHost();\n/**\n * メッセージリスナー\n *\n * このリスナーは以下の3種類のメッセージを処理します：\n * 1. Geminiタブからの「準備完了」通知\n * 2. Geminiタブからの応答メッセージ（MCPサーバーに転送）\n * 3. ポップアップUIなど他のソースからのコマンド（Geminiタブに転送）\n */\nchrome.runtime.onMessage.addListener((message, sender) => {\n    var _a;\n    // Geminiタブからのメッセージを処理\n    if (sender.tab && ((_a = sender.tab.url) === null || _a === void 0 ? void 0 : _a.includes('gemini.google.com'))) {\n        const tabId = sender.tab.id;\n        if (tabId) {\n            // タブからの「準備完了」通知を処理\n            if (message.type === 'content_ready') {\n                console.log(`%c[MCP-Background] Tab ID: ${tabId} is now ready.`, 'color: green;');\n                geminiTabStatus[tabId] = true;\n                // キューに溜まっていたメッセージがあれば送信\n                if (messageQueue[tabId] && messageQueue[tabId].length > 0) {\n                    console.log(`[MCP-Background] Sending ${messageQueue[tabId].length} queued messages to Tab ID: ${tabId}`);\n                    messageQueue[tabId].forEach(queuedMsg => {\n                        chrome.tabs.sendMessage(tabId, queuedMsg);\n                    });\n                    delete messageQueue[tabId];\n                }\n                return;\n            }\n        }\n        // Geminiからの応答をMCPサーバーに転送\n        if (message.status && nativePort) {\n            nativePort.postMessage(message);\n        }\n    }\n    // ポップアップUIなど他のソースからのコマンドを処理\n    else if (!sender.tab && message.command) {\n        sendCommandsToGeminiTab(message);\n    }\n    return true; // 非同期レスポンスを有効にする\n});\n/**\n * Geminiタブにコマンドメッセージを送信する関数\n *\n * この関数はMCPサーバーやポップアップUIからのコマンドをGeminiタブに転送します。\n * タブが準備できていない場合は、メッセージをキューに入れて後で送信します。\n *\n * @param message - Geminiタブに送信するコマンドメッセージ\n */\nfunction sendCommandsToGeminiTab(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Geminiタブを検索\n        const tabs = yield chrome.tabs.query({ url: \"https://gemini.google.com/*\" });\n        if (tabs.length === 0)\n            return; // Geminiタブが見つからない場合は何もしない\n        const targetTab = tabs[0];\n        if (targetTab && typeof targetTab.id !== 'undefined') {\n            const tabId = targetTab.id;\n            // タブが準備できていない場合はメッセージをキューに入れる\n            if (!geminiTabStatus[tabId]) {\n                console.warn(`[MCP-Background] Tab ${tabId} is not ready yet. Queuing message.`, message);\n                if (!messageQueue[tabId])\n                    messageQueue[tabId] = [];\n                messageQueue[tabId].push(message);\n                return;\n            }\n            // タブが準備できている場合はメッセージを直接送信\n            chrome.tabs.sendMessage(tabId, message);\n        }\n    });\n}\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[994](0, __webpack_exports__);\n"],"names":["__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","nativePort","geminiTabStatus","messageQueue","sendCommandsToGeminiTab","message","tabs","chrome","query","url","length","targetTab","id","tabId","console","warn","push","sendMessage","connectToNativeHost","log","runtime","connectNative","onMessage","addListener","onDisconnect","error","lastError","setTimeout","forEach","tab","command","sender","_a","includes","type","queuedMsg","status","postMessage"],"sourceRoot":""}